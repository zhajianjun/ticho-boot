package top.ticho.tool.core.ulid;

import java.io.Serial;
import java.io.Serializable;
import java.time.Instant;
import java.util.Arrays;
import java.util.UUID;
import java.util.concurrent.ThreadLocalRandom;

/**
 * 一个表示ULID的类。
 * <p>
 * ULID是一个128位的值，它由两个部分组成：
 * <ul>
 * <li><b>时间组件</b>: 自1970年1月1日以来的毫秒（Unixepoch）。</li>
 * <li><b>随机组件</b>: a sequence of 80 random bits generated by a secure random generator.</li>
 * </ul>
 * <p>
 * ULID具有128位的兼容性。 {@link UUID}. 就像UUID一样，ULID也可以被存储为一个16字节的数组。
 * <p>
 * 这个类的实例是 <b>不可变的</b>.
 *
 * @see <a href="https://github.com/ulid/spec">ULID Specification</a>
 */
public final class Ulid implements Serializable, Comparable<Ulid> {
    @Serial
    private static final long serialVersionUID = 2625269413446854731L;

    /**
     * 最高有效位位
     */
    private final long msb;
    /**
     * 最低有效位
     */
    private final long lsb;
    /**
     * ULID 的字符数
     */
    public static final int ULID_CHARS = 26;

    /**
     * ULID的字节数。
     */
    public static final int ULID_BYTES = 16;
    /**
     * ULID随机组件的字节数。
     */
    public static final int RANDOM_BYTES = 10;
    /**
     * 一个特殊ULID，所有128位都设置为零。
     */
    public static final Ulid MIN = new Ulid(0x0000000000000000L, 0x0000000000000000L);
    /**
     * 一个特殊ULID，所有128位都设置为一。
     */
    public static final Ulid MAX = new Ulid(0xffffffffffffffffL, 0xffffffffffffffffL);


    static final byte[] ALPHABET_VALUES = new byte[256];
    static final char[] ALPHABET_UPPERCASE = "0123456789ABCDEFGHJKMNPQRSTVWXYZ".toCharArray();
    static final char[] ALPHABET_LOWERCASE = "0123456789abcdefghjkmnpqrstvwxyz".toCharArray();

    static {

        // 用-1初始化字母表映射
        Arrays.fill(ALPHABET_VALUES, (byte) -1);

        for (int i = 0; i < ALPHABET_UPPERCASE.length; i++) {
            ALPHABET_VALUES[ALPHABET_UPPERCASE[i]] = (byte) i;
        }
        for (int i = 0; i < ALPHABET_LOWERCASE.length; i++) {
            ALPHABET_VALUES[ALPHABET_LOWERCASE[i]] = (byte) i;
        }

        // 大写
        ALPHABET_VALUES['O'] = 0x00;
        ALPHABET_VALUES['I'] = 0x01;
        ALPHABET_VALUES['L'] = 0x01;

        // 小写
        ALPHABET_VALUES['o'] = 0x00;
        ALPHABET_VALUES['i'] = 0x01;
        ALPHABET_VALUES['l'] = 0x01;
    }

    // 0xffffffffffffffffL + 1 = 0x0000000000000000L
    private static final long INCREMENT_OVERFLOW = 0x0000000000000000L;

    /**
     * 创建一个新的ULID。
     * <p>
     * 用于制作ULID的副本。
     *
     * @param ulid 一个ULID
     */
    public Ulid(Ulid ulid) {
        this.msb = ulid.msb;
        this.lsb = ulid.lsb;
    }


    /**
     * 创建一个新的ULID。
     * <p>
     * 如果你想复制一个 {@link UUID}，请使用 {@link Ulid#from(UUID)}。
     *
     * @param mostSignificantBits  前8个字节作为长整型值
     * @param leastSignificantBits 后8个字节作为长整型值
     */
    public Ulid(long mostSignificantBits, long leastSignificantBits) {
        this.msb = mostSignificantBits;
        this.lsb = leastSignificantBits;
    }


    /**
     * 创建一个新的ULID。
     * <p>
     * 时间参数是自1970年1月1日以来的毫秒数，也称为Unix纪元。
     * 它必须是一个不大于2^48-1的正数。
     * <p>
     * 随机参数必须是10个字节的任意数组。
     * <p>
     * 注意：ULID不能由1970年1月1日之前的日期组成，因为它们的嵌入式时间戳
     * 在内部被视为无符号整数，即它只能表示包括零在内的自然数集，最大到2^48-1。
     *
     * @param time   自1970年1月1日以来的毫秒数
     * @param random 10个字节的数组
     * @throws IllegalArgumentException 如果时间是负数或大于2^48-1
     * @throws IllegalArgumentException 如果随机数为null或长度不是10
     */
    public Ulid(long time, byte[] random) {

        // 48位。
        if ((time & 0xffff000000000000L) != 0) {
            // ULID规范:
            // 任何解码或编码大于这个（时间大于2 ^48-1）的uid的尝试都应该被所有实现拒绝，以防止溢出错误。
            // 溢出或负时间！
            throw new IllegalArgumentException("Invalid time value");
        }
        // 随机组件有80位（10字节）。
        if (random == null || random.length != RANDOM_BYTES) {
            // Null或错误的长度！
            throw new IllegalArgumentException("Invalid random bytes");
        }

        long long0 = 0;
        long long1 = 0;

        long0 |= time << 16;
        long0 |= (long) (random[0x0] & 0xff) << 8;
        long0 |= (long) (random[0x1] & 0xff);

        long1 |= (long) (random[0x2] & 0xff) << 56;
        long1 |= (long) (random[0x3] & 0xff) << 48;
        long1 |= (long) (random[0x4] & 0xff) << 40;
        long1 |= (long) (random[0x5] & 0xff) << 32;
        long1 |= (long) (random[0x6] & 0xff) << 24;
        long1 |= (long) (random[0x7] & 0xff) << 16;
        long1 |= (long) (random[0x8] & 0xff) << 8;
        long1 |= (long) (random[0x9] & 0xff);

        this.msb = long0;
        this.lsb = long1;
    }

    /**
     * 返回一个新的快速ULID。
     * <p>
     * 这个静态方法是 {@link UlidCreator#getUlid()} 的快速替代方案。
     * <p>
     * 它使用 {@link ThreadLocalRandom}，效果很好，虽然不是加密强度的。
     * 它可能很有用，例如用于日志记录。
     * <p>
     * 需要加密安全伪随机生成器的安全敏感应用程序应使用 {@link UlidCreator#getUlid()}。
     *
     * @return 一个ULID
     * @since 5.1.0
     */
    public static Ulid fast() {
        final long time = System.currentTimeMillis();
        ThreadLocalRandom random = ThreadLocalRandom.current();
        return new Ulid((time << 16) | (random.nextLong() & 0xffffL), random.nextLong());
    }


    /**
     * 返回给定时间的最小ULID。
     * <p>
     * 时间组件的48位用给定时间填充，随机组件的80位全部设置为零。
     * <p>
     * 例如，2022-02-22 22:22:22.222的最小ULID是
     * `{@code new Ulid(0x017f2387460e0000L, 0x0000000000000000L)}`，其中
     * `{@code 0x017f2387460e}`是十六进制的时间戳。
     * <p>
     * 它可以用于在没有 `{@code created_at}` 字段的表中查找特定时间戳之前或之后的所有记录。
     *
     * @param time 自1970年1月1日以来的毫秒数
     * @return 一个ULID
     * @since 5.2.0
     */
    public static Ulid min(long time) {
        return new Ulid((time << 16), 0x0000000000000000L);
    }

    /**
     * 返回给定时间的最大ULID。
     * <p>
     * 时间组件的48位用给定时间填充，随机组件的80位全部设置为一。
     * <p>
     * 例如，2022-02-22 22:22:22.222的最大ULID是
     * `{@code new Ulid(0x017f2387460effffL, 0xffffffffffffffffL)}`，其中
     * `{@code 0x017f2387460e}`是十六进制的时间戳。
     * <p>
     * 它可以用于在没有 `{@code created_at}` 字段的表中查找特定时间戳之前或之后的所有记录。
     *
     * @param time 自1970年1月1日以来的毫秒数
     * @return 一个ULID
     * @since 5.2.0
     */
    public static Ulid max(long time) {
        return new Ulid((time << 16) | 0xffffL, 0xffffffffffffffffL);
    }

    /**
     * 将UUID转换为ULID。
     */
    public static Ulid from(UUID uuid) {
        return new Ulid(uuid.getMostSignificantBits(), uuid.getLeastSignificantBits());
    }

    /**
     * 将字节数组转换为ULID。
     *
     * @param bytes 16个字节的数组
     * @return 一个ULID
     * @throws IllegalArgumentException 如果字节为null或长度不是16
     */
    public static Ulid from(byte[] bytes) {
        if (bytes == null || bytes.length != ULID_BYTES) {
            throw new IllegalArgumentException("Invalid ULID bytes");
        }
        long msb = 0;
        long lsb = 0;
        msb |= (bytes[0x0] & 0xffL) << 56;
        msb |= (bytes[0x1] & 0xffL) << 48;
        msb |= (bytes[0x2] & 0xffL) << 40;
        msb |= (bytes[0x3] & 0xffL) << 32;
        msb |= (bytes[0x4] & 0xffL) << 24;
        msb |= (bytes[0x5] & 0xffL) << 16;
        msb |= (bytes[0x6] & 0xffL) << 8;
        msb |= (bytes[0x7] & 0xffL);

        lsb |= (bytes[0x8] & 0xffL) << 56;
        lsb |= (bytes[0x9] & 0xffL) << 48;
        lsb |= (bytes[0xa] & 0xffL) << 40;
        lsb |= (bytes[0xb] & 0xffL) << 32;
        lsb |= (bytes[0xc] & 0xffL) << 24;
        lsb |= (bytes[0xd] & 0xffL) << 16;
        lsb |= (bytes[0xe] & 0xffL) << 8;
        lsb |= (bytes[0xf] & 0xffL);

        return new Ulid(msb, lsb);
    }

    /**
     * 将规范字符串转换为ULID。
     * <p>
     * 输入字符串必须是26个字符长，并且只能包含Crockford的base 32字母表中的字符。
     * <p>
     * 输入字符串的第一个字符必须在0到7之间。
     *
     * @param string 规范字符串
     * @return 一个ULID
     * @throws IllegalArgumentException 如果输入字符串无效
     * @see <a href="https://www.crockford.com/base32.html">Crockford的Base 32</a>
     */
    public static Ulid from(String string) {

        final char[] chars = toCharArray(string);

        long time = 0;
        long random0 = 0;
        long random1 = 0;

        time |= (long) ALPHABET_VALUES[chars[0x00]] << 45;
        time |= (long) ALPHABET_VALUES[chars[0x01]] << 40;
        time |= (long) ALPHABET_VALUES[chars[0x02]] << 35;
        time |= (long) ALPHABET_VALUES[chars[0x03]] << 30;
        time |= (long) ALPHABET_VALUES[chars[0x04]] << 25;
        time |= (long) ALPHABET_VALUES[chars[0x05]] << 20;
        time |= (long) ALPHABET_VALUES[chars[0x06]] << 15;
        time |= (long) ALPHABET_VALUES[chars[0x07]] << 10;
        time |= (long) ALPHABET_VALUES[chars[0x08]] << 5;
        time |= (long) ALPHABET_VALUES[chars[0x09]];

        random0 |= (long) ALPHABET_VALUES[chars[0x0a]] << 35;
        random0 |= (long) ALPHABET_VALUES[chars[0x0b]] << 30;
        random0 |= (long) ALPHABET_VALUES[chars[0x0c]] << 25;
        random0 |= (long) ALPHABET_VALUES[chars[0x0d]] << 20;
        random0 |= (long) ALPHABET_VALUES[chars[0x0e]] << 15;
        random0 |= (long) ALPHABET_VALUES[chars[0x0f]] << 10;
        random0 |= (long) ALPHABET_VALUES[chars[0x10]] << 5;
        random0 |= (long) ALPHABET_VALUES[chars[0x11]];

        random1 |= (long) ALPHABET_VALUES[chars[0x12]] << 35;
        random1 |= (long) ALPHABET_VALUES[chars[0x13]] << 30;
        random1 |= (long) ALPHABET_VALUES[chars[0x14]] << 25;
        random1 |= (long) ALPHABET_VALUES[chars[0x15]] << 20;
        random1 |= (long) ALPHABET_VALUES[chars[0x16]] << 15;
        random1 |= (long) ALPHABET_VALUES[chars[0x17]] << 10;
        random1 |= (long) ALPHABET_VALUES[chars[0x18]] << 5;
        random1 |= (long) ALPHABET_VALUES[chars[0x19]];

        final long msb = (time << 16) | (random0 >>> 24);
        final long lsb = (random0 << 40) | (random1 & 0xffffffffffL);

        return new Ulid(msb, lsb);
    }

    /**
     * 将ULID转换为UUID。
     * <p>
     * ULID与 {@link UUID} 具有128位兼容性。
     * <p>
     * 如果你需要RFC-4122 UUIDv4，请执行：{@code Ulid.toRfc4122().toUuid()}。
     *
     * @return 一个UUID。
     */
    public UUID toUuid() {
        return new UUID(this.msb, this.lsb);
    }

    /**
     * 将ULID转换为字节数组。
     *
     * @return 一个字节数组。
     */
    public byte[] toBytes() {

        final byte[] bytes = new byte[ULID_BYTES];

        bytes[0x0] = (byte) (msb >>> 56);
        bytes[0x1] = (byte) (msb >>> 48);
        bytes[0x2] = (byte) (msb >>> 40);
        bytes[0x3] = (byte) (msb >>> 32);
        bytes[0x4] = (byte) (msb >>> 24);
        bytes[0x5] = (byte) (msb >>> 16);
        bytes[0x6] = (byte) (msb >>> 8);
        bytes[0x7] = (byte) (msb);

        bytes[0x8] = (byte) (lsb >>> 56);
        bytes[0x9] = (byte) (lsb >>> 48);
        bytes[0xa] = (byte) (lsb >>> 40);
        bytes[0xb] = (byte) (lsb >>> 32);
        bytes[0xc] = (byte) (lsb >>> 24);
        bytes[0xd] = (byte) (lsb >>> 16);
        bytes[0xe] = (byte) (lsb >>> 8);
        bytes[0xf] = (byte) (lsb);

        return bytes;
    }


    /**
     * 将ULID转换为大写的规范字符串。
     * <p>
     * 输出字符串是26个字符长，只包含Crockford的Base 32字母表中的字符。
     * <p>
     * 对于小写字符串，请使用简写 {@code Ulid#toLowerCase()}，而不是
     * {@code Ulid#toString()#toLowerCase()}。
     *
     * @return 一个ULID字符串
     * @see <a href="https://www.crockford.com/base32.html">Crockford的Base 32</a>
     */
    @Override
    public String toString() {
        return toString(ALPHABET_UPPERCASE);
    }

    /**
     * 将ULID转换为小写的规范字符串。
     * <p>
     * 输出字符串是26个字符长，只包含Crockford的Base 32字母表中的字符。
     * <p>
     * 这是一个简写形式，至少比{@code Ulid.toString().toLowerCase()} 快两倍。
     *
     * @return 一个字符串
     * @see <a href="https://www.crockford.com/base32.html">Crockford的Base 32</a>
     */
    public String toLowerCase() {
        return toString(ALPHABET_LOWERCASE);
    }

    /**
     * 将ULID转换为与UUIDv4兼容的另一个ULID。
     * <p>
     * 返回的ULID的字节符合RFC-4122版本4。
     * <p>
     * 如果你需要RFC-4122 UUIDv4，请执行：{@code Ulid.toRfc4122().toUuid()}。
     * <p>
     * <b>注意：</b>如果使用此方法，你将无法获得原始的ULID，因为它会更改其中的6位来生成UUIDv4。
     *
     * @return 一个ULID
     * @see <a href="https://www.rfc-editor.org/rfc/rfc4122">RFC-4122</a>
     */
    public Ulid toRfc4122() {

        // 将第7个字节的最高4位设置为0、1、0和0。RFC-4122 version 4
        final long msb4 = (this.msb & 0xffffffffffff0fffL) | 0x0000000000004000L;
        // 将第9个字节的最高两位设置为1和0。RFC-4122 variant 2
        final long lsb4 = (this.lsb & 0x3fffffffffffffffL) | 0x8000000000000000L;

        return new Ulid(msb4, lsb4);
    }

    public Instant getInstant() {
        return Instant.ofEpochMilli(this.getTime());
    }

    /**
     * 返回创建的瞬间。
     * <p>
     * 创建的瞬间是从时间组件中提取的。
     *
     * @return 创建的 {@link Instant}
     */
    public static Instant getInstant(String string) {
        return Instant.ofEpochMilli(getTime(string));
    }

    /**
     * 返回时间组件作为一个数字。
     * <p>
     * 时间组件是0到2^48-1之间的数字。它等同于自1970年1月1日以来的毫秒计数(Unix epoch)。
     *
     * @return 毫秒数
     */
    public long getTime() {
        return this.msb >>> 16;
    }

    /**
     * 将时间组件作为数字返回。
     * <p>
     * 时间组件是0到2^48-1之间的数字。它等同于自1970年1月1日以来的毫秒计数（Unix纪元）。
     *
     * @param string 规范字符串
     * @return 毫秒数
     * @throws IllegalArgumentException 如果输入字符串无效
     */
    public static long getTime(String string) {

        final char[] chars = toCharArray(string);

        long time = 0;

        time |= (long) ALPHABET_VALUES[chars[0x00]] << 45;
        time |= (long) ALPHABET_VALUES[chars[0x01]] << 40;
        time |= (long) ALPHABET_VALUES[chars[0x02]] << 35;
        time |= (long) ALPHABET_VALUES[chars[0x03]] << 30;
        time |= (long) ALPHABET_VALUES[chars[0x04]] << 25;
        time |= (long) ALPHABET_VALUES[chars[0x05]] << 20;
        time |= (long) ALPHABET_VALUES[chars[0x06]] << 15;
        time |= (long) ALPHABET_VALUES[chars[0x07]] << 10;
        time |= (long) ALPHABET_VALUES[chars[0x08]] << 5;
        time |= (long) ALPHABET_VALUES[chars[0x09]];

        return time;
    }

    /**
     * 返回随机组件作为字节数组。
     * <p>
     * 随机组件是10个字节(80位)的数组。
     *
     * @return 一个字节数组
     */
    public byte[] getRandom() {

        final byte[] bytes = new byte[RANDOM_BYTES];

        bytes[0x0] = (byte) (msb >>> 8);
        bytes[0x1] = (byte) (msb);

        bytes[0x2] = (byte) (lsb >>> 56);
        bytes[0x3] = (byte) (lsb >>> 48);
        bytes[0x4] = (byte) (lsb >>> 40);
        bytes[0x5] = (byte) (lsb >>> 32);
        bytes[0x6] = (byte) (lsb >>> 24);
        bytes[0x7] = (byte) (lsb >>> 16);
        bytes[0x8] = (byte) (lsb >>> 8);
        bytes[0x9] = (byte) (lsb);

        return bytes;
    }

    /**
     * 将随机组件作为字节数组返回。
     * <p>
     * 随机组件是10个字节（80位）的数组。
     *
     * @param string 规范字符串
     * @return 一个字节数组
     * @throws IllegalArgumentException 如果输入字符串无效
     */
    public static byte[] getRandom(String string) {

        final char[] chars = toCharArray(string);

        long random0 = 0;
        long random1 = 0;

        random0 |= (long) ALPHABET_VALUES[chars[0x0a]] << 35;
        random0 |= (long) ALPHABET_VALUES[chars[0x0b]] << 30;
        random0 |= (long) ALPHABET_VALUES[chars[0x0c]] << 25;
        random0 |= (long) ALPHABET_VALUES[chars[0x0d]] << 20;
        random0 |= (long) ALPHABET_VALUES[chars[0x0e]] << 15;
        random0 |= (long) ALPHABET_VALUES[chars[0x0f]] << 10;
        random0 |= (long) ALPHABET_VALUES[chars[0x10]] << 5;
        random0 |= (long) ALPHABET_VALUES[chars[0x11]];

        random1 |= (long) ALPHABET_VALUES[chars[0x12]] << 35;
        random1 |= (long) ALPHABET_VALUES[chars[0x13]] << 30;
        random1 |= (long) ALPHABET_VALUES[chars[0x14]] << 25;
        random1 |= (long) ALPHABET_VALUES[chars[0x15]] << 20;
        random1 |= (long) ALPHABET_VALUES[chars[0x16]] << 15;
        random1 |= (long) ALPHABET_VALUES[chars[0x17]] << 10;
        random1 |= (long) ALPHABET_VALUES[chars[0x18]] << 5;
        random1 |= (long) ALPHABET_VALUES[chars[0x19]];

        final byte[] bytes = new byte[RANDOM_BYTES];

        bytes[0x0] = (byte) (random0 >>> 32);
        bytes[0x1] = (byte) (random0 >>> 24);
        bytes[0x2] = (byte) (random0 >>> 16);
        bytes[0x3] = (byte) (random0 >>> 8);
        bytes[0x4] = (byte) (random0);

        bytes[0x5] = (byte) (random1 >>> 32);
        bytes[0x6] = (byte) (random1 >>> 24);
        bytes[0x7] = (byte) (random1 >>> 16);
        bytes[0x8] = (byte) (random1 >>> 8);
        bytes[0x9] = (byte) (random1);

        return bytes;
    }

    public long getMostSignificantBits() {
        return this.msb;
    }

    public long getLeastSignificantBits() {
        return this.lsb;
    }

    /**
     * 通过递增当前ULID的随机组件返回一个新的ULID。
     * <p>
     * 由于随机组件包含80位：
     * <ul>
     * <li>(1) 此方法每毫秒可以生成多达1208925819614629174706176 (2^80)个ULID；
     * <li>(2) 此方法可以在单个毫秒间隔内99.999999999999992% ((2^80 - 10^9) / (2^80))的时间内生成单调递增的ULID，
     * 考虑到每毫秒生成1,000,000,000个ULID的不现实速率。
     * </ul>
     * <p>
     * 由于(1)和(2)，它不会抛出规范推荐的错误消息。当80位随机数发生溢出时，
     * 时间组件简单地递增以<b>保持单调性</b>。
     *
     * @return 一个ULID
     */
    public Ulid increment() {
        long newMsb = this.msb;
        // 增加最低有效位
        long newLsb = this.lsb + 1;
        if (newLsb == INCREMENT_OVERFLOW) {
            // 增加最高有效位
            newMsb += 1;
        }
        return new Ulid(newMsb, newLsb);
    }

    /**
     * 检查输入字符串是否有效。
     * <p>
     * 输入字符串必须有26个字符长，并且必须只包含Crockford的base 32字母表中的字符
     * <p>
     * 输入字符串的第一个字符必须在0 ~ 7之间。
     *
     * @see <a href="https://www.crockford.com/base32.html">Crockford's Base 32</a>
     */
    public static boolean isValid(String string) {
        return string != null && isValidCharArray(string.toCharArray());
    }

    @Override
    public int hashCode() {
        return Long.hashCode(msb ^ lsb);
    }

    @Override
    public boolean equals(Object other) {
        if (other == null) {
            return false;
        }
        if (other.getClass() != Ulid.class) {
            return false;
        }
        Ulid that = (Ulid) other;
        if (lsb != that.lsb) {
            return false;
        }
        return msb == that.msb;

    }

    /**
     * 将两个uid作为无符号128位整数进行比较。
     * <p>
     * 如果两个ULID中最大字节的差异大于第一个ULID，则两个ULID中的第一个大于第二个。
     */
    @Override
    public int compareTo(Ulid that) {
        final long min = 0x8000000000000000L;
        final long a = this.msb + min;
        final long b = that.msb + min;
        if (a > b) {
            return 1;
        } else if (a < b) {
            return -1;
        }
        final long c = this.lsb + min;
        final long d = that.lsb + min;
        if (c > d) {
            return 1;
        } else if (c < d) {
            return -1;
        }
        return 0;
    }

    String toString(char[] alphabet) {
        final char[] chars = new char[ULID_CHARS];
        long time = this.msb >>> 16;
        long random0 = ((this.msb & 0xffffL) << 24) | (this.lsb >>> 40);
        long random1 = (this.lsb & 0xffffffffffL);

        chars[0x00] = alphabet[(int) (time >>> 45 & 0b11111)];
        chars[0x01] = alphabet[(int) (time >>> 40 & 0b11111)];
        chars[0x02] = alphabet[(int) (time >>> 35 & 0b11111)];
        chars[0x03] = alphabet[(int) (time >>> 30 & 0b11111)];
        chars[0x04] = alphabet[(int) (time >>> 25 & 0b11111)];
        chars[0x05] = alphabet[(int) (time >>> 20 & 0b11111)];
        chars[0x06] = alphabet[(int) (time >>> 15 & 0b11111)];
        chars[0x07] = alphabet[(int) (time >>> 10 & 0b11111)];
        chars[0x08] = alphabet[(int) (time >>> 5 & 0b11111)];
        chars[0x09] = alphabet[(int) (time & 0b11111)];

        chars[0x0a] = alphabet[(int) (random0 >>> 35 & 0b11111)];
        chars[0x0b] = alphabet[(int) (random0 >>> 30 & 0b11111)];
        chars[0x0c] = alphabet[(int) (random0 >>> 25 & 0b11111)];
        chars[0x0d] = alphabet[(int) (random0 >>> 20 & 0b11111)];
        chars[0x0e] = alphabet[(int) (random0 >>> 15 & 0b11111)];
        chars[0x0f] = alphabet[(int) (random0 >>> 10 & 0b11111)];
        chars[0x10] = alphabet[(int) (random0 >>> 5 & 0b11111)];
        chars[0x11] = alphabet[(int) (random0 & 0b11111)];

        chars[0x12] = alphabet[(int) (random1 >>> 35 & 0b11111)];
        chars[0x13] = alphabet[(int) (random1 >>> 30 & 0b11111)];
        chars[0x14] = alphabet[(int) (random1 >>> 25 & 0b11111)];
        chars[0x15] = alphabet[(int) (random1 >>> 20 & 0b11111)];
        chars[0x16] = alphabet[(int) (random1 >>> 15 & 0b11111)];
        chars[0x17] = alphabet[(int) (random1 >>> 10 & 0b11111)];
        chars[0x18] = alphabet[(int) (random1 >>> 5 & 0b11111)];
        chars[0x19] = alphabet[(int) (random1 & 0b11111)];
        return new String(chars);
    }

    static char[] toCharArray(String string) {
        char[] chars = string == null ? null : string.toCharArray();
        if (!isValidCharArray(chars)) {
            throw new IllegalArgumentException(String.format("Invalid ULID: \"%s\"", string));
        }
        return chars;
    }

    /**
     * 检查字符串是否为有效的uid。
     * <p>
     * 一个有效的uid字符串是Crockford的Base 32的26个字符的序列
     * 字母。
     * <p>
     * 输入字符串的第一个字符必须在0到7之间。
     */
    static boolean isValidCharArray(final char[] chars) {

        if (chars == null || chars.length != ULID_CHARS) {
            return false;
        }

        for (char aChar : chars) {
            try {
                // 无效字符！
                if (ALPHABET_VALUES[aChar] == -1) {
                    return false;
                }
            } catch (ArrayIndexOutOfBoundsException e) {
                return false;
            }
        }
        // 时间为48位。
        // base32编码的时间分量为50位。
        // 时间分量不能大于2^48-1。
        // 因此base32解码时间分量的前2位必须为0。
        // 因此，输入字符串的第一个字符必须在0到7之间。
        // uuid规格：
        // "任何尝试解码或编码大于此的uid （time > 2^48-1）
        // 应该被所有实现拒绝，以防止溢出错误。”
        return (ALPHABET_VALUES[chars[0]] & 0b11000) == 0;
    }

}
